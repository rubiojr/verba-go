import sql
import rsx

/*
 * verba.civio.es client library.
*/

const _VERBA_URL = "https://verba.civio.es/api"

func _get(path, opts) {
  return fetch(_VERBA_URL + path, opts)
}

func programmes() {
  resp := _get("/fetchProgrammeList", {})
  if resp.status_code != 200 {
    error("error fetching programmes")
  }

  return resp.json()
}

func transcription(programme_id) {
  resp := _get("/fetchProgrammeTranscription", {params: {programme_id: programme_id}})
  if resp.status_code != 200 {
    error("error fetching transcription")
  }

  return resp.json()
}

func create_db(dbfile) {
  db := sql.connect('sqlite://{dbfile}')
  db.exec("PRAGMA foreign_keys=ON")
  db.exec(`PRAGMA journal_mode=WAL`)
  db.exec(`
    CREATE TABLE IF NOT EXISTS programmes (
      id INTEGER PRIMARY KEY,
      title TEXT,
      date DATETIME
    )
  `)

  db.exec(`
    CREATE TABLE IF NOT EXISTS sync (
      id INTEGER PRIMARY KEY,
      programme_id TEXT,
      date DATETIME
    )
  `)

  db.exec(`
    CREATE TABLE IF NOT EXISTS transcripts (
      id INTEGER PRIMARY KEY,
      transcript_id TEXT NOT NULL,
      programme_id INTEGER,
      content TEXT,
      link TEXT,
      time_start INTEGER,
      time_end INTEGER,
      FOREIGN KEY(programme_id) REFERENCES programmes(id)
    );
    CREATE UNIQUE INDEX IF NOT EXISTS transcriptididx ON transcripts(transcript_id);
    CREATE VIRTUAL TABLE IF NOT EXISTS tidx USING fts5(id UNINDEXED, content);

    CREATE TRIGGER IF NOT EXISTS transcript_insert AFTER INSERT ON transcripts BEGIN
      INSERT INTO
        tidx (id, content)
      VALUES
        (new.rowid, new.content);
    END;

    CREATE TRIGGER IF NOT EXISTS transcript_delete AFTER DELETE ON transcripts BEGIN
      DELETE FROM tidx WHERE id = old.rowid;
    END;
  `)
}

func sync(dbfile) {
  if !rsx.is_file(dbfile) {
    print('Database file "{dbfile}" does not exist')
    return
  }

  db := sql.connect('sqlite://'+dbfile)
  db.exec("PRAGMA foreign_keys=ON")
  db.exec(`PRAGMA journal_mode=WAL`)

  programmes := programmes()
  count := 0
  programmes.each(func(p) {
    rows := db.query(`SELECT * from sync where programme_id = ?`, p.id)
    if len(rows) == 0 {
      print('Syncing new programme [{count}/{len(programmes)}] {p.id} ({p.date})...')
      db.exec(
        `INSERT INTO programmes (id, title, date) VALUES (?, ?, ?) ON CONFLICT(id) DO UPDATE SET title=title`,
        p.id, p.title, p.date,
      )

      print('Syncing transcriptions...')
      transcription := transcription(p.id)
      transcription.each(func(t) {
        db.exec(
          `INSERT INTO transcripts (transcript_id, content, programme_id, link, time_start, time_end) VALUES (?, ?, ?, ?, ?, ?) ON CONFLICT(transcript_id) DO UPDATE SET content=content`,
          t.id, t.content, int(t.programme.id), t.link, t.time_start, t.time_end,
        )
      })

      db.exec(
        `INSERT INTO sync (programme_id, date) VALUES (?, ?)`,
        p.id, p.date,
      )
      count++
    } else {
      rsx.debug('Programme {p.id} ({p.date}) already synced')
    }
    true
  })
  print('Synced {count} programmes.')
}

func search(dbfile, q) {
  if !rsx.is_file(dbfile) {
    print('Database file "{dbfile}" does not exist')
    return
  }

  db := sql.connect('sqlite://{dbfile}')
  db.exec("PRAGMA foreign_keys=ON")
  db.exec(`PRAGMA journal_mode=WAL`)
  db.exec(`PRAGMA query_only=ON`)
  db.query(
    `SELECT t.id, t.programme_id, p.date, p.title, idx.content, t.link
    FROM transcripts t
    JOIN tidx idx ON (idx.rowid = t.id)
    JOIN programmes p ON (p.id = t.programme_id)
    WHERE idx.content MATCH ?
    ORDER BY p.date ASC`,
    q).each(func(row){
    print(sprintf(">> %s <<\nid: %d, programme_id: %d, date: %s\nlink: %s\n%s", row.title, row.id, row.programme_id, row.date.format(time.RFC822), row.link, row.content))
  })
}

func download(basedir) {
  print('Saving data to {basedir}...')
  os.mkdir_all(filepath.join(basedir, "transcripts"))
  os.mkdir_all(filepath.join(basedir, "programmes"))

  prog := programmes()
  print("Saving programmes...")
  dest_file := filepath.join(basedir, '/programmes/{time.now().unix()}.json')
  f := os.create(dest_file)
  defer f.close()
  json.marshal(prog) | f.write

  print("Saving transcripts...")
  count := 0
  prog.each(func(e) {
    dest_file := filepath.join(basedir, '/transcripts/{e.id}-verba-transcript.json')

    if rsx.is_file(dest_file) {
      rsx.debug('Transcript for programme {e.id} exists, skipping...')
      return
    }
    count++

    print('Downloading transcript for {e.id} ({e.date})...')
    f := os.create(dest_file+ ".tmp")
    defer f.close()

    t := transcription(e.id)
    json.marshal(t) | f.write
    os.rename(dest_file+ ".tmp", dest_file)
  })
  print('Downloaded {count} transcripts.')
}
